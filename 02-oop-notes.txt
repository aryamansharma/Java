OOP in Java :
1. classes and objects in Java :
    * For every method we need to provide access modifiers.

    class Calculator {

        // this int here is the return type of this method.
        public int add(int n1, int n2) {
            int result = n1+n2;
            return 
        }
        
        // if we dont a method to return anything we use void, like this
        public void play(){ // this method will return anything

        }

        // if we want to specify the return type as String for a method, we use it like this
        public String abc() { // this String we use to specify the return of this method

        }
    }

    public class Demo {
        public static void main(String a[]) {
            int num1 = 1;
            int num2 = 2;

            // this is how we create an object of a class in Java.
            // this Calculator will be the type of the variable(object in this case).
            // calc will be the object or we can say it will be a reference variable.
            // new Calculator() will be used to create object of this Calculator class.
            Calculator calc = new Calculator();
            int result = calc.add(num1+num2);
            System.out.println(result);
        }
    }

    * anonymous object :
     class Calculator {
    }
     public class Demo {
        public static void main(String a[]) {
            int num1 = 1;
            int num2 = 2;

            // this is anonymous object.
            new Calculator(); 
            // this is not usefull because we cannot use it further.
        }
    }

2. method overloading : when we have 2 implementation of a method with the exact same name, 
    the only difference will be between the paramenters adn the type of paramenters.

    class Abc {
        public int add(int a, int b, int c) {
            return a+b+c;
        }
        public int add(int a, int b) {
            return a+b;
        }
    }

    class Main {
        public static void main(String a[]) {
            Abc obj = new Abc();
            obj.add(1,2,3); //this will call the 1st implementation
            obj.add(1,2); // this will call the 2nd implementation
        }
    }

3. how code is executed inside JVM:
    suppose we have a structure like this : 
    
    class Abc {
        int num = 1; // this will be called as an instance variable.

        public int add(int a, int b) { // these a and b will be the local variables.
            return a+b;
        }

    }
    
    class Main {
        public static void main(String a[]) {
            Abc obj1 = new Abc();
            Abc obj2 = new Abc();

            obj1.num = 5;
            System.out.println(obj1.num); // output : 5
            System.out.println(obj2.num); // output : 1
        }
    }

    stack and heap :
    * every function will be having its own stack.
    * heap will be having all the objects created from a class.
    * stack will be having key value pairs, where key will be the local variable of the function and value of the key will be the value fo the variable.
    * in case of objects, inside the stack, the value for the object key will be the address for that object inside the heap.

4. encapsulation : meaning hiding the data and methods from other parts of the program.
    * we can use getters and setters to implement encapsulation.
    * instance variable should always be private.

    class Human {
        private int age;
        private String name;

        // getter for age
        public getAge() {
            return this.age;
        }

        // setter for age
        public setAge(int age) {
            this.age = age;
        }
    }

    class Demo {
        public static void main(String a[]) {
            Human obj = new Human();
            obj.setAge(25);
            System.out.println(obj.getAge());
        }
    }

5. In java if we do something like this:
    class Human {
        private int age;
        private String name;

        public Human(int a, String n) {
            age = age;
            name = name;

            // this assignment without this keyword is valid, 
            but we should not do this because arguements and instance variables can have same name,
            so in that case it will not assign the value to the instance variables.
        }
    }

    class Demo {
        public static void main(String a[]) {
            Human obj = new Human(25,"Aryaman");
        }
    }

6. this keyword works in java just like Javascript.

7. constructor : constructor of class will always run whenver we create an object of that class.
    * syntax : 

    class Human {
        private int age;
        private String name;

        // this is a constructor. the name of the constructor will be same as the class in Java.
        // this is known as a default constructor. it will always be present in the class, even if you dont define one yourself.
        public Human() {

        }
    }

    * we can overload constructor as as well :
      class Human {
        private int age;
        private String name;

        public Human() {

        }

        // these are called parameterized constructors.
        public Human(int age, String name) {
            this.age = age;
            this.name = name;
        }
    }

8. inheritance : 
    // this Calc will be the super class or parent class or base class
    class Calc {
        public int add(int num1, int num2) {
            return num1+num2;
        }
        public int sub(int num1, int num2) {
            return num1-num2;
        }
    }

    // this AdvanceCalc will be the sub class or child class or derived class
    class AdvanceCalc extends Calc {
        public int multi(int num1, int num2) {
            return num1*num2;
        }
        public int division(int num1, int num2) {
            return num1/num2;
        }
    }

    class Main {
        public static void main(String a[]) {
            AdvanceCalc obj = new AdvanceCalc();

            // even though add method is not defined in the AdvanceCalc class, we can still use it due to inheritance.
            obj.add(2,3);

            if we do something like this :
            Calc obj2 = new Calc();
            obj2.multi(2,3); // this will not work
        }
    }

9. types of inheritance : 
    1. single inheritance :  when there is just 1 parent class and 1 child class.
    2. multilevel inheritance :
        when we have a parent class and we derived a class from that class, 
        and then we again derive a class from the already derived class and so on, this is multilevel inheritance.
    3. multiple inheritance : when there are 2 parent class of a single child class.
        * in java multiple inheritance is not possible, because of ambiguity problem, which stated that :
            * suppose we have 2 parent classes and a single child class derived from those 2 parent classes and we create an object of that child class,
            and we use that object to call a method named x() and that method is not present in the child class but it is present in both the parent classes,
            so compiler will get confuse which x() method to call, so that is why multiple inheritance is not possible in java.

10. this() method and super method() :
    1. this() method is used to execute the constructor of that class.
    2. super() method is used to execute the constructor of the parent class.

    eg :

    // all the classes in java will extend Object whether you mention it or not.
    class A extends Object {

        public A() {
            // all the constructors of a class will having this super() method and will be the 1 call first in a constructor.
            super(); // this will call the constructor of the Object class
            System.out.println("A default constructor");
        }

        public A(int n) {
            super();
            System.out.println("A parameterized constructor");
        }
    }

    class B extends A {
        public B() {
            super(5); // this way we can call the parameterized constructor of the parent class.
            this(5); // this will the parameterized constructor of this class.
            System.out.println("B default constructor");
        }

        public B(int n) {
            super();
            this(); // this method is will execut the constructor of the same class. 
            System.out.println("B parameterized constructor");
        }
    }

    class Main {
        public static void main(String a[]) {
            B obj = new B(); // creating an object of B
        }
    }

11. method overriding : 
    * suppose we have a method with exact same name in both the parent class and in child class as well,
    and we create an object of child class and call that method , so the method of child class will be executed.
    this is method overriding.
    if we dont have the method in our child class but in our parent class, then the parent class method will be executed.

